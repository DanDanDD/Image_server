# SE

### 1、String、StringBuffer、StringBuilder有什么区别

​	String：适用于少量的字符串操作的情况

​	StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况

​	StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

**区别**主要在 **线程安全**   和   **执行速度**   上体现

​	StringBuffer是线程安全，

​	StringBuilder是非同步，速度就比StringBuffer快多了;

​	执行速度： StringBuilder > StringBuffer > String

**为什么 String 最慢？**

​	-》String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。

​	例如：String str = "ab";      str = str + "c";

​	在上面代码中，jvm 底层先创建了个对象 str 并把值赋给了它，然后又创建了一个str 对象，把原先str 的值和 "c" 相加后，赋给了新的 str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了

### 2、

StringBuffer与StringBuilder两者共同之处:可以通过append、indert进行字符串的操作。



# JUC







# 网络

### 1、输入 URL 后发生的事

​	①浏览器查看浏览器缓存-系统缓存（本地 /etc/ hosts文件）-路由器缓存，如果缓存中有，则直接显示页面内容

​	②进行DNS解析，解析出对应的 IP 地址 

​	③浏览器向服务器发起建立 TCP 连接 

​	④浏览器向服务器发送 HTTP 请求 

​	⑤服务器收到HTTP请求，数据返回给浏览器 

​	⑥浏览器收到HTTP响应 

​	⑦开始读取页面内容、渲染页面 

#### 	DNS解析(工作在应用层)的详细过程：

1. 主机先向本地域名服务器进行**递归查询**

2. 本地域名服务器采用**迭代查询**，向一个根域名服务器进行查询

3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址

4. 本地域名服务器向顶级域名服务器进行查询

5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址

6. 本地域名服务器向权限服务器进行查询

7. 权限服务器告诉本地域名服务器所查询的主机的IP地址

8. 本地域名服务器最后把查询结果告诉主机

   **递归查询：**本机向本地域名服务器发出一次查询请求，就静待最终的结果；如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询

   **迭代查询：**本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询



### 2、HTTP问题大集合

#### HTTP常见的状态码有哪些？

![image-20200904181109818](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200904181109818.png)

​	200 OK 常见的成功状态码，如果是非 HEAD 请求，返回响应头部会有 body数据

​	204 No Content 与200相同，但是头部没有 body 数据

​	206 Partial Content 用于HTTP分块下载和断电续传，响应返回的body数据不是全部资源

​	301 永久重定向，请求资源已经不存在，需要改用新的URL访问

​	302 临时重定向，需要使用另一个URL来访问

​	二者都会在响应头中的 Location 指明重定向的URL

​	304 缓存重定向，不具有跳转含义，重定向已存在缓冲文件

​	400 客户端请求报文有错，笼统错误

​	403 服务器静止访问资源，并不是客户端出错

​	404 请求资源在服务器上不存在或未找到

​	500 笼统错误，服务器出错

​	501 客户端请求的功能还不支持

​	502 服务器作为网关或代理时，访问后端服务器出错

​	503 服务器正忙，稍后重试



#### HTTP常见的字段有哪些？

​	Host ：指定服务器域名

​	Content-Length：表明本次回应的数据长度

​	Connection ：keep-alive 客户端请求服务器使用TCP持久连接

​	Content-Type：服务器回应客户端，本次数据是什么格式

​	Content-Encoding：服务器返回数据采用什么压缩方法



#### GET和POST的区别是什么？

​	GET：从服务器获取资源（静态文本、页面、图片、视频等）

​		比如，你打开我的博客，浏览器就会发送 GET 请求给服务器，服务器就会返回	文章的所有文字及资源

​	POST：向 URL 指定的资源提交数据，数据就放在报文的 body 里

​		比如，你在我的博客留言并点击提交，浏览器就会执行POST请求，把留言的文字放进报文body里，然后拼接好POST请求头，通过TCP协议发给服务器



#### GET和POST 方法都是安全和幂等的吗？

安全：请求方法不会破坏服务器上的资源

幂等：多次执行相同的操作，结果都是相同的

​	GET方法就是安全且幂等的，因为 GET 方法是 **只读** 操作

​	POST方法不安全且不是幂等的，它会提交数据，会修改服务器上的资源

#### HTTP(1.1)的优缺点？

**！！！优点！！！**

HTTP 最突出的优点是「简单、灵活易于扩展、应用广泛 和 跨平台」

​	**1.简单：**HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式

​	**2.灵活易扩展：**HTTP 中的各类请求方法、URL、状态码、头子段等都没有被固定死，允许开发人员自定义和扩展。	同时 HTTP 工作在应用层，它的下层可以随意变化

​	HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层

​	**3.应用广泛和跨平台：**从电脑浏览器、手机APP 等，都是HTTP 的应用



**！！！缺点！！！**

​	**无状态（优点）：**服务器不会去记忆 HTTP 的状态，则不需要额外的资源来记录状态信息，能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务

​	**1.无状态（缺点）：**服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如 登录->加购物车->下单->结算，这一系列操作中每次都要访问一遍身份信息

​	=解决方案： Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。相对于，在客户端第一次请求后，服务器会给客户端带上一个标记，之后再请求时，就能认得客户端了

**2.明文传输：**

（优点）方便调试、直接抓包、F12查看报文

（缺点）内容会被窃听、不验证对方身份访问了假的网站、不能保证报文完整性可能被篡改

​	解决方案：可以用 HTTPS 的方式解决，通过引入 SSL/TLS 层，使得在安全上达标



#### HTTP(1.1)的性能如何？

​	HTTP是基于 TCP/IP,使用了 请求-应答 的通信模式

​	1.**长连接**：在HTTP(1.0)中，每次发起一个请求都建立一次TCP连接，且是串行请求，性能低、开销大

​		而在HTTP(1.1)中，提出了**长连接**的通信方式（只要任意一端没有明确提出断开连接，则保持 TCP 连接状态），减少了重复建立和断开连接的开销

​	2.**管道网络传输**:服务器允许客户端连续发送请求，服务器还是按照顺序回应请求，但如果开始的请求处理太慢还是会造成阻塞，称为 “队头阻塞”，而在后续的HTTP/2，HTTP/3都做出了优化



#### HTTP和HTTPS区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 **SSL/TLS 安全协议**，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



#### HTTPS如何解决HTTP中的不安全问题

由于HTTP是明文传输，所以会有以下风险

窃听风险 -> 信息加密 (混合加密)

篡改风险 -> 校验机制 (摘要算法)

冒充风险 -> 身份证书 (数字证书)

**1.混合加密：**            

**[非对称加密]：**通信建立前采用非对称加密方式交换[会话秘钥]， 						  后续则不使用非对称加密      								(使用两个密钥，公钥和私钥，私钥保留，公钥分发出去，做到了安全的密钥交换，但是速度慢)

**[对称加密] ：**通信过程中全部使用对称加密的[会话秘钥]的方式		     	      加密明文数据															(只使用一个密钥，无法做到安全的密钥交换，但是运算速度快)

**2.摘要算法**

摘要算法主要体现了数据的完整性，可以为数据提供独一无二的**“标识”**，用来验证数据的完整性，防止在传输中被篡改

​	客户端发送明文前通过摘要算法计算出特殊**标识**，发送时将明文和标识一起加密，服务器收到并解密后，再根据摘要算法算出**标识**进行对比

**3.数字证书**

客户端向服务器索要公钥，**服务器将公钥放在CA(数字证书)中**，发给客户端，只要证书是可信的，公钥就是真的，之后客户端发送消息使用公钥加密，服务器再使用私钥解密，就可以安全传输了。



#### HTTPS是如何建立连接的？

​	SSL/TLS 协议基本流程：

* 客户端向服务器索要并验证服务器的公钥

* 双方协商生产 [会话秘钥] 

* 双方采用 [会话秘钥] 进行加密通信

**SSL/TSL 的握手是 四次通信 的过程**

​	①客户端向服务器发送请求														客户端支持的SSL/TSL版本、客户端产生的随机数(用来产生密钥)、客户端支持的加密算法

​	②服务器响应																				   确认SSL/TSL版本如果不支持关闭加密通信、服务器产生随机数、确认支持的加密算法、服务器的数字证书

​	③客户端回应																				先根据浏览器或支持系统中的**CA公钥**确认证书真伪、一个经过加密的随机数、通知服务器下来的信息都使用 [密钥] 加密

​	④服务器最后回应	将刚刚发送来的**加密随机数**通过加密算法计算出 [密钥]、通知客户端随后信息都使用 [密钥] 加密通信、握手结束通知，同时把之前所有的内容都进行**摘要**，以供客户端校验



#### HTTP/1.0    HTTP/1.1     HTTP/2     HTTP/3 优化

​	1.0 -> 1.1 : ①使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销	②支持 管道（pipeline）网络传输

​	1.1 -> 2 : ①HTTP/2 是基于 HTTPS 的，安全性有保障			②**头部压缩算法**，客户端和服务器共同维护一个头信息表，将字段存入表中，同时生成索引号，之后发生索引号，提供速度		③**采用二进制格式**，头信息和数据体都是二进制，提供传输效率④**多路复用**，可以在一个连接中并发多个请求和回应，降低了延迟，避免了[队头阻塞]																	 ⑤**数据流(stream)**，HTTP/2 的数据包不是按顺序发送，所以对数据包做标记，指出它属于哪个回应；客户端还可以指定数据流的优先级，服务器优先响应															   ⑥**服务器推送(Cache Push)**，服务器可以主动向客户端发送消息，例如 : 浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待												





# MySQL

# Linux



# JVM

### 1、从栈帧看字节码如何在JVM中流转

怎么查看字节码文件？

对象初始化后，具体字节码怎么执行？

#### 分析字节码的小工具：

①  javap    将 .class 字节码文件解析成可读的文件格式

javap -v 

javap -p 打印私有字段和方法

```java
javap -p -v HelloWorld
```

在 **Stack Overflow** 上有一个非常有意思的问题：我在某个类中增加一行注释之后，为什么两次生成的 **.class** 文件，它们的 **MD5** 是不一样的？

这是因为在 **javac** 中可以指定一些额外的内容输出到字节码。经常用的有

* javac -g:lines 强制生成 LineNumberTable。
* javac -g:vars  强制生成 LocalVariableTable。
* javac -g 生成所有的 debug 信息

②  **jclasslib** 图形化工具，直观的查询字节码中的内容

​         Idea 中有插件，可以从 plugins 中搜索到



##### 类的初始化发生在类的加载阶段

##### 对象的创建方式有什么？

* new

* Class 的 newInstance 方法

* Constructor 类的 newInstance 方法

* 反序列化                                      （未调用构造方法）

* Object 的 clone 方法                  （未调用构造方法）

  

![image-20200815005040962](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200815005040962.png)

A 和 B 会被加载到元空间的方法区，进入 main 方法后，将会交给执行引擎执行。

这个执行过程是在栈上完成的，其中有几个重要的区域，包括虚拟机栈、程序计数器等



#### 查看字节码

##### 命令行查看

↓ 编译源代码 A.java

```java
javac -g:lines -g:vars A.java
```

这将强制生成 LineNumberTable 和 LocalVariableTable

后使用 javap 命令查看 A 和 B 的字节码

```java
javap -p -v A.class
javap -p -v B.class
```

这个命令不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息

```java
javap 中显示的字样
1: invokespecial #1                  // Method java/lang/Object."<init>":()V
```

对象的初始化，首先调用了 Object 类的初始化方法，注意 <init> 

##### clinit  和 init

<clinit>方法在类加载过程中执行的，而<init>在对象实例化时执行,所以<clinit>一定比<init>先执行

<init>:会将变量初始化,初始化语句块，构造器方法等操作顺序封装到该方法中

- 父类的静态变量初始化
- 父类的静态代码块
- 子类的静态变量初始化
- 子类的静态代码块
- 父类的变量初始化
- 父类的初始化代码块
- 父类的构造方法
- 子类的变量初始化
- 子类的初始化代码块
- 子类的构造方法