# 操作系统



### 1、CPU的执行方式

几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：**取指令、指令译码、执行指令、访存取数、结果写回**

**CUP的组成：**

1.寄存器;
2.控制器CU（Control Unit）:
     指令寄存器IR(InstructionRegister)、程序计数器PC(ProgramCounter)和操作控制器OC(OperationController);
3.ALU（算数逻辑运算单元），不包括寄存器;
4.总览

### 2、CPU调度算法：

​	①先来先服务(FCFS)

​	②短时间优先(SJF)

​	③时间片轮转算法

​	④优先级调度

# SE

### 1、String、StringBuffer、StringBuilder有什么区别

​	String：适用于少量的字符串操作的情况

​	StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况

​	StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

**区别**主要在 **线程安全**   和   **执行速度**   上体现

​	StringBuffer是线程安全，

​	StringBuilder是非同步，速度就比StringBuffer快多了;

​	执行速度： StringBuilder > StringBuffer > String

**为什么 String 最慢？**

​	-》String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。

​	例如：String str = "ab";      str = str + "c";

​	在上面代码中，jvm 底层先创建了个对象 str 并把值赋给了它，然后又创建了一个str 对象，把原先str 的值和 "c" 相加后，赋给了新的 str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了

StringBuffer与StringBuilder**两者共同之处**:可以通过append、indert进行字符串的操作。

### 2、了解泛型吗？泛型有什么作用？知道泛型的上下界的概念吗?

​	泛型：把**类型明确的工作**推迟到创建对象或调用方法的时候才去明确的特殊类型。

​	把类型当做是参数一样传递            <数据类型> 只能是引用类型

​	**早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全**

**泛型的上下界问题：**

如果要从集合中读取类型T的数据，并且**不能写入**，可以使用        ? extends 通配符；(Producer Extends)   上界<? extends T>不能往里存，只能往外取

如果要从集合中写入类型T的数据，并且**不需要读取**，可以使用    ? super 通配符；(Consumer Super)	下界<? super T>不影响往里存，但往外取只能放在Object对象里



## 异常

异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它

#### 1、异常的结构和种类 

![image-20200911113013451](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200911113013451.png)

Throwable：Java中所有错误和异常的超类

**Error：**运行应用程序出现严重错误，一般都是代码运行时 JVM 出现问题，例如 StackOverflowError(栈溢出错误)、NoClassDefFoundError(类定义错误)、OutOfMemoryError(内存不足错误)；**JVM会终止线程**

**Exception：**程序本身可以捕获并处理的异常，又分为**运行时异常**、**编译时异常**



#### 2、运行时异常、编译时异常

**RuntimeException：**在 JVM 运行期间可能出现的异常

​	Java 编译器不会检查它，可以通过编译，在运行时报出异常。例如：NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。**此类异常属于非受检异常**，一般是**由程序逻辑错误引起**的，在程序中可以选择捕获处理，也可以不处理。

**编译时异常：**Exception 中除 RuntimeException 及其子类之外的异常

​	Java 编译器会检查它。如果程序中出现此类异常，比如ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译



#### 3、受查异常、非受查异常

**受查异常：**除了RuntimeException及子类外，其他的Exception 都属于受查异常

​	编译器必须要求处理的异常

**非受查异常：**运行时异常（RuntimeException及其子类）和错误（Error）

​	不进行处理，编译器也会通过



#### 4、Java异常关键字

• **try** – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。

• **catch** – 用于捕获异常。catch用来捕获try语句块中发生的异常。

• **finally** – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。**如果 try 或者 catch 中含有 return，则也会先执行finally，再执行 try - catch 中的 return** ；如果finally中使用了return或者throw等终止方法的语句，则直接停止。

• **throw** – 用于抛出异常。

• **throws** – 用在方法签名中，用于声明该方法可能抛出的异常。



#### 5、JVM 如何处理异常的

​	一个方法中如果存在异常，这个方法会创建一个异常对象，并转交给 JVM (这个过程称为抛出异常)，其中会有一系列的方法调用(称为调用栈)，JVM 或顺着调用栈去查看是否有处理异常的代码，如果有则把异常传递给它；如果没有则 JVM 会把异常传给默认的异常处理器，默认异常处理器会打印异常信息，终止应用程序。





# JUC

### 1、进程和线程的区别：

​	①根本区别：进程是操作系统资源分配的最小单位  **|**  线程是操作系统调度、执行的最小单位

​	②包含关系：进程里至少包含一个线程，线程是进程的一部分

​	③内存和开销：进程有自己独立的地址空间和资源，进程间切换开销较大  **|**  线程共享所在进程的地址空间和资源，每个线程有自己独立的运行栈和程序计数器

​	④影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响  **|**  线程崩溃后其他线程也会受到影响，整个进程都会崩溃

### 2、线程间、进程间的通信方式：

**①进程：**

**管道**：半双工，只能在父子进程间使用，速度慢

**有名管道**：半双工，允许任何关系的进程通信

**信号量**：计数器，控制多进程对共享资源的访问，也是线程间的同步手段

**消息队列**：消息构成的链表，第一次读的时候要考虑上次没有读完的数据

**信号**：通知接收进程某个事件已经发生

**共享内存**：要保持同步，传输速度快

**套接字**：用于不同设备及其间的进程通信



**②线程：**

**互斥锁**：提供了以排他方式防止数据结构被并发修改的方法。

**读写锁**：允许多个线程同时读共享数据，而对写操作是互斥的

**条件变量**：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。**条件变量始终与互斥锁一起使用**。

**信号量(Semaphore)**：包含无名线程信号量 和 命名线程信号量											

**信号机制(Signal)**：类似进程间的信号处理

​	**线程间的通信目的主要是用于线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制



### 守护线程和用户线程

​	**用户进程(User Thread)：**运行在前台，执行具体任务，例如程序的主线程都是用户线程

​	**守护线程(Daemon Thread)：**运行在后台，为其他前台线程服务，一旦所有的用户线程都结束运行，守护线程也会结束工作，例如垃圾回收线程



### 3、并发编程

#### 优点：

​	充分利用多核CPU的计算能力：通过并发编程的形式可以将多核CPU的计算能力发挥到极致，大大的提高性能。

​	方便业务拆分，提高系统的并发能力和性能：面对复杂的业务模型，并发程序会比串行程序更适合业务需求。

#### 缺点：

​	内存泄漏问题、上下文切换、线程安全问题、死锁问题

#### 三要素：

​	原子性：多个操作执行，要么都成功、要么都失败

​	可见性：一个线程对共享变量进行修改，其他线程都能看到

​	

# 网络

### 1、输入 URL 后发生的事

​	①浏览器查看浏览器缓存-系统缓存（本地 /etc/ hosts文件）-路由器缓存，如果缓存中有，则直接显示页面内容

​	②进行DNS解析，解析出对应的 IP 地址 

​	③浏览器向服务器发起建立 TCP 连接 

​	④浏览器向服务器发送 HTTP 请求 

​	⑤服务器收到HTTP请求，数据返回给浏览器 

​	⑥浏览器收到HTTP响应 

​	⑦开始读取页面内容、渲染页面 

#### 	DNS解析(工作在应用层)的详细过程：

1. 主机先向本地域名服务器进行**递归查询**

2. 本地域名服务器采用**迭代查询**，向一个根域名服务器进行查询

3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址

4. 本地域名服务器向顶级域名服务器进行查询

5. 顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址

6. 本地域名服务器向权限服务器进行查询

7. 权限服务器告诉本地域名服务器所查询的主机的IP地址

8. 本地域名服务器最后把查询结果告诉主机

   **递归查询：**本机向本地域名服务器发出一次查询请求，就静待最终的结果；如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询

   **迭代查询：**本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询



### 2、HTTP问题大集合

#### HTTP常见的状态码有哪些？

![image-20200904181109818](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200904181109818.png)

​	200 OK 常见的成功状态码，如果是非 HEAD 请求，返回响应头部会有 body数据

​	204 No Content 与200相同，但是头部没有 body 数据

​	206 Partial Content 用于HTTP分块下载和断电续传，响应返回的body数据不是全部资源

​	301 永久重定向，请求资源已经不存在，需要改用新的URL访问

​	302 临时重定向，需要使用另一个URL来访问

​	二者都会在响应头中的 Location 指明重定向的URL

​	304 缓存重定向，不具有跳转含义，重定向已存在缓冲文件

​	400 客户端请求报文有错，笼统错误

​	403 服务器静止访问资源，并不是客户端出错

​	404 请求资源在服务器上不存在或未找到

​	500 笼统错误，服务器出错

​	501 客户端请求的功能还不支持

​	502 服务器作为网关或代理时，访问后端服务器出错

​	503 服务器正忙，稍后重试



#### HTTP封装后的数据报格式

![image-20200912010955350](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200912010955350.png)



#### HTTP常见的字段有哪些？

​	Host ：指定服务器域名

​	Content-Length：表明本次回应的数据长度

​	Connection ：keep-alive 客户端请求服务器使用TCP持久连接

​	Content-Type：服务器回应客户端，本次数据是什么格式

​	Content-Encoding：服务器返回数据采用什么压缩方法



#### GET和POST的区别是什么？

​	**GET：**从服务器获取资源（静态文本、页面、图片、视频等）

​		比如，你打开我的博客，浏览器就会发送 GET 请求给服务器，服务器就会返回	文章的所有文字及资源

​	**POST：**向 URL 指定的资源提交数据，数据就放在报文的 body 里

​		比如，你在我的博客留言并点击提交，浏览器就会执行POST请求，把留言的文字放进报文body里，然后拼接好POST请求头，通过TCP协议发给服务器

|              |                GET                 |            POST             |
| :----------- | :--------------------------------: | :-------------------------: |
| 数据长度限制 | 给URL中存放数据，而URL最大长度2048 |           无限制            |
| 数据类型限制 |          只允许ASCII字符           |           无限制            |
| 安全性       |   安全性较差，数据是URL的一部分    |            较好             |
| 可见性       |     数组在URL中，对所有人可见      |      放在Body中不可见       |
| 存放位置     |          数据存放在URL中           | 可以在URL中，也可以在Body中 |



#### GET和POST 方法都是安全和幂等的吗？

安全：请求方法不会破坏服务器上的资源

幂等：多次执行相同的操作，结果都是相同的

​	GET方法就是安全且幂等的，因为 GET 方法是 **只读** 操作

​	POST方法不安全且不是幂等的，它会提交数据，会修改服务器上的资源



#### HTTP(1.1)的优缺点？

**！！！优点！！！**

HTTP 最突出的优点是「简单、灵活易于扩展、应用广泛 和 跨平台」

​	**1.简单：**HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式

​	**2.灵活易扩展：**HTTP 中的各类请求方法、URL、状态码、头子段等都没有被固定死，允许开发人员自定义和扩展。	同时 HTTP 工作在应用层，它的下层可以随意变化

​	HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层

​	**3.应用广泛和跨平台：**从电脑浏览器、手机APP 等，都是HTTP 的应用



**！！！缺点！！！**

​	**无状态（优点）：**服务器不会去记忆 HTTP 的状态，则不需要额外的资源来记录状态信息，能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务

​	**1.无状态（缺点）：**服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如 登录->加购物车->下单->结算，这一系列操作中每次都要访问一遍身份信息

​	=解决方案： Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。相对于，在客户端第一次请求后，服务器会给客户端带上一个标记，之后再请求时，就能认得客户端了

**2.明文传输：**

（优点）方便调试、直接抓包、F12查看报文

（缺点）内容会被窃听、不验证对方身份访问了假的网站、不能保证报文完整性可能被篡改

​	解决方案：可以用 HTTPS 的方式解决，通过引入 SSL/TLS 层，使得在安全上达标



#### Cookie 和 Session

​	Cookie就是为了**弥补HTTP协议无状态**这一不足出现的机制；

​	**Cookie**：本质上就是一段文本信息。客户端请求服务器的时候，如果服务器需要记录该用户，就用response向客户端颁发一个Cookie。**客户端会把Cookie保存起来**，当再次访问请求这个服务器的时候，客户端把请求的URI和Cookie一起发送给服务器，服务器检查Cookie，以此来辨别用户状态

​	**Session**：是服务器端使用的一种记录客户端状态的机制，在客户端访问服务器的时候，服务器会开辟一块内存空间，**将用户身份信息保存到服务器上**，存储结构为ConcurrentHashMap，再次访问的时候只需要从该Session中查找用户信息就行

​	因为Session存在服务器内存中，且每个用户独立，为了防止内存溢出，服务器会清理长时间没有活跃的Session



#### Cookie 和 Session 联系

​	在服务器第一次收到请求后，创建 Session 对象，生成 Session_id，并通过响应头中的 Set-Cookie 命令，向客户端要求使用 Cookie（将Session_id 放入到Cookie中），客户端收到响应后，之后每次向服务器发送请求时都会带上该 Cookie 信息。服务器读取请求头中的 Cookie信息，就可以得到本次请求的 Session_id



#### HTTP(1.1)的性能如何？

​	HTTP是基于 TCP/IP,使用了 请求-应答 的通信模式

​	1.**长连接**：在HTTP(1.0)中，每次发起一个请求都建立一次TCP连接，且是串行请求，性能低、开销大

​		而在HTTP(1.1)中，提出了**长连接**的通信方式（只要任意一端没有明确提出断开连接，则保持 TCP 连接状态），减少了重复建立和断开连接的开销

​	2.**管道网络传输**:服务器允许客户端连续发送请求，服务器还是按照顺序回应请求，但如果开始的请求处理太慢还是会造成阻塞，称为 “队头阻塞”，而在后续的HTTP/2，HTTP/3都做出了优化



#### HTTP和HTTPS区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 **SSL/TLS 安全协议**，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



#### HTTPS如何解决HTTP中的不安全问题

由于HTTP是明文传输，所以会有以下风险

窃听风险 -> 信息加密 (混合加密)

篡改风险 -> 校验机制 (摘要算法)

冒充风险 -> 身份证书 (数字证书)

**1.混合加密：**            

**[非对称加密]：**通信建立前采用非对称加密方式交换[会话秘钥]， 						  后续则不使用非对称加密      								(使用两个密钥，公钥和私钥，私钥保留，公钥分发出去，做到了安全的密钥交换，但是速度慢)

**[对称加密] ：**通信过程中全部使用对称加密的[会话秘钥]的方式		     	      加密明文数据															(只使用一个密钥，无法做到安全的密钥交换，但是运算速度快)

**2.摘要算法**

摘要算法主要体现了数据的完整性，可以为数据提供独一无二的**“标识”**，用来验证数据的完整性，防止在传输中被篡改

​	客户端发送明文前通过摘要算法计算出特殊**标识**，发送时将明文和标识一起加密，服务器收到并解密后，再根据摘要算法算出**标识**进行对比

**3.数字证书**

客户端向服务器索要公钥，**服务器将公钥放在CA(数字证书)中**，发给客户端，只要证书是可信的，公钥就是真的，之后客户端发送消息使用公钥加密，服务器再使用私钥解密，就可以安全传输了。



#### HTTPS是如何建立连接的？

​	SSL/TLS 协议基本流程：

* 客户端向服务器索要并验证服务器的公钥

* 双方协商生产 [会话秘钥] 

* 双方采用 [会话秘钥] 进行加密通信

**SSL/TSL 的握手是 四次通信 的过程**

​	①客户端向服务器发送请求：客户端支持的SSL/TSL版本、客户端产生的随机数(用来产生密钥)、客户端支持的加密算法

​	②服务器响应： 确认SSL/TSL版本如果不支持关闭加密通信、服务器产生随机数、确认支持的加密算法、服务器的数字证书

​	③客户端回应：先根据浏览器或支持系统中的**CA公钥**确认证书真伪、一个经过加密的随机数、通知服务器下来的信息都使用 [密钥] 加密

​	④服务器最后回应：将刚刚发送来的**加密随机数**通过加密算法计算出 [密钥]、通知客户端随后信息都使用 [密钥] 加密通信、握手结束通知，同时把之前所有的内容都进行**摘要**，以供客户端校验



#### HTTP/1.0    HTTP/1.1     HTTP/2     HTTP/3 优化

​	1.0 -> 1.1 : ①使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销	②支持 管道（pipeline）网络传输

​	1.1 -> 2 : ①HTTP/2 是基于 HTTPS 的，安全性有保障			②**头部压缩算法**，客户端和服务器共同维护一个头信息表，将字段存入表中，同时生成索引号，之后发生索引号，提供速度		③**采用二进制格式**，头信息和数据体都是二进制，提供传输效率④**多路复用**，可以在一个连接中并发多个请求和回应，降低了延迟，避免了[队头阻塞]																	 ⑤**数据流(stream)**，HTTP/2 的数据包不是按顺序发送，所以对数据包做标记，指出它属于哪个回应；客户端还可以指定数据流的优先级，服务器优先响应															   ⑥**服务器推送(Cache Push)**，服务器可以主动向客户端发送消息，例如 : 浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待	



​											

### 3、TCP / IP

HTTP 和 TCP 的区别





# MySQL

#### 数据库的三大范式：

第一范式：保证每列的原子性

第二范式：确保表中每列都和主键相关 

第三范式：确保每列都和主键列直接相关,而不是间接相关





# Linux







# JVM

### 1、从栈帧看字节码如何在JVM中流转

怎么查看字节码文件？

对象初始化后，具体字节码怎么执行？

#### 分析字节码的小工具：

①  javap    将 .class 字节码文件解析成可读的文件格式

javap -v 

javap -p 打印私有字段和方法

```java
javap -p -v HelloWorld
```

在 **Stack Overflow** 上有一个非常有意思的问题：我在某个类中增加一行注释之后，为什么两次生成的 **.class** 文件，它们的 **MD5** 是不一样的？

这是因为在 **javac** 中可以指定一些额外的内容输出到字节码。经常用的有

* javac -g:lines 强制生成 LineNumberTable。
* javac -g:vars  强制生成 LocalVariableTable。
* javac -g 生成所有的 debug 信息

②  **jclasslib** 图形化工具，直观的查询字节码中的内容

​         Idea 中有插件，可以从 plugins 中搜索到



##### 对象的创建方式有什么？

* new

* Class 的 newInstance 方法

* Constructor 类的 newInstance 方法

* 反序列化                                      （未调用构造方法）

* Object 的 clone 方法                  （未调用构造方法）

  

![image-20200815005040962](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200815005040962.png)

A 和 B 会被加载到元空间的方法区，进入 main 方法后，将会交给执行引擎执行。

这个执行过程是在栈上完成的，其中有几个重要的区域，包括虚拟机栈、程序计数器等



#### 查看字节码的方法

**命令行查看**

↓ 编译源代码 A.java

```java
javac -g:lines -g:vars A.java
```

这将强制生成 LineNumberTable 和 LocalVariableTable

后使用 javap 命令查看 A 和 B 的字节码

```java
javap -p -v A.class
javap -p -v B.class
```

这个命令不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息

```java
javap 中显示的字样
1: invokespecial #1                  // Method java/lang/Object."<init>":()V
```

对象的初始化，首先调用了 Object 类的初始化方法，注意 <init> 

#### clinit  和 init

<clinit>方法在类加载过程中执行的，而<init>在对象实例化时执行,所以<clinit>一定比<init>先执行

<init>:会将变量初始化,初始化语句块，构造器方法等操作顺序封装到该方法中

- 父类的静态变量初始化
- 父类的静态代码块
- 子类的静态变量初始化
- 子类的静态代码块
- 父类的变量初始化
- 父类的初始化代码块
- 父类的构造方法
- 子类的变量初始化
- 子类的初始化代码块
- 子类的构造方法



#### Java类加载器：

类加载器：负责动态加载Java类到Java虚拟机的内存空间中，也就是将外部的 .class 文件加载到 Java方法区内

**类加载器分为四类：**

- 1、启动类加载器：任何类的加载的行为都经过它，用来加载核心类库

- 2、扩展类加载器：用来加载Java扩展类库，JVM虚拟机会提供一个扩展类目录，该类加载器在其中查找并加载类

- 3、Java默认类加载器：根据Java应用程序的类路径来加载

- 4、自定义类加载器：程序员自己实现，通过继承 java.long.ClassLoader 类实现