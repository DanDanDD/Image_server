# SE

### 1、String、StringBuffer、StringBuilder有什么区别

​	String：适用于少量的字符串操作的情况

​	StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况

​	StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

**区别**主要在 **线程安全**   和   **执行速度**   上体现

​	StringBuffer是线程安全，

​	StringBuilder是非同步，速度就比StringBuffer快多了;

​	执行速度： StringBuilder > StringBuffer > String

**为什么 String 最慢？**

​	-》String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。

​	例如：String str = "ab";      str = str + "c";

​	在上面代码中，jvm 底层先创建了个对象 str 并把值赋给了它，然后又创建了一个str 对象，把原先str 的值和 "c" 相加后，赋给了新的 str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了

### 2、

StringBuffer与StringBuilder两者共同之处:可以通过append、indert进行字符串的操作。



# JUC







# 网络

### 1、输入 URL 后发生的事

​	①进行URL解析







### 2、HTTP问题大集合

##### HTTP常见的状态码有哪些？

![image-20200904181109818](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200904181109818.png)

​	200 OK 常见的成功状态码，如果是非 HEAD 请求，返回响应头部会有 body数据

​	204 No Content 与200相同，但是头部没有 body 数据

​	206 Partial Content 用于HTTP分块下载和断电续传，响应返回的body数据不是全部资源

​	301 永久重定向，请求资源已经不存在，需要改用新的URL访问

​	302 临时重定向，需要使用另一个URL来访问

​	二者都会在响应头中的 Location 指明重定向的URL

​	304 缓存重定向，不具有跳转含义，重定向已存在缓冲文件

​	400 客户端请求报文有错，笼统错误

​	403 服务器静止访问资源，并不是客户端出错

​	404 请求资源在服务器上不存在或未找到

​	500 笼统错误，服务器出错

​	501 客户端请求的功能还不支持

​	502 服务器作为网关或代理时，访问后端服务器出错

​	503 服务器正忙，稍后重试



##### HTTP常见的字段有哪些？

​	Host ：指定服务器域名

​	Content-Length：表明本次回应的数据长度

​	Connection ：keep-alive 客户端请求服务器使用TCP持久连接

​	Content-Type：服务器回应客户端，本次数据是什么格式

​	Content-Encoding：服务器返回数据采用什么压缩方法



##### GET和POST的区别是什么？

​	GET：从服务器获取资源（静态文本、页面、图片、视频等）

​		比如，你打开我的博客，浏览器就会发送 GET 请求给服务器，服务器就会返回	文章的所有文字及资源

​	POST：向 URL 指定的资源提交数据，数据就放在报文的 body 里

​		比如，你在我的博客留言并点击提交，浏览器就会执行POST请求，把留言的文字放进报文body里，然后拼接好POST请求头，通过TCP协议发给服务器



##### GET和POST 方法都是安全和幂等的吗？

安全：请求方法不会破坏服务器上的资源

幂等：多次执行相同的操作，结果都是相同的

​	GET方法就是安全且幂等的，因为 GET 方法是 **只读** 操作

​	POST方法不安全且不是幂等的，它会提交数据，会修改服务器上的资源

##### HTTP(1.1)的优缺点？

**！！！优点！！！**

HTTP 最突出的优点是「简单、灵活易于扩展、应用广泛 和 跨平台」

​	**1.简单：**HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式

​	**2.灵活易扩展：**HTTP 中的各类请求方法、URL、状态码、头子段等都没有被固定死，允许开发人员自定义和扩展。	同时 HTTP 工作在应用层，它的下层可以随意变化

​	HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层

​	**3.应用广泛和跨平台：**从电脑浏览器、手机APP 等，都是HTTP 的应用



**！！！缺点！！！**

​	**无状态（优点）：**服务器不会去记忆 HTTP 的状态，则不需要额外的资源来记录状态信息，能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务

​	**1.无状态（缺点）：**服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如 登录->加购物车->下单->结算，这一系列操作中每次都要访问一遍身份信息

​	=解决方案： Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。相对于，在客户端第一次请求后，服务器会给客户端带上一个标记，之后再请求时，就能认得客户端了

**2.明文传输：**

（优点）方便调试、直接抓包、F12查看报文

（缺点）内容会被窃听、不验证对方身份访问了假的网站、不能保证报文完整性可能被篡改

​	解决方案：可以用 HTTPS 的方式解决，通过引入 SSL/TLS 层，使得在安全上达标

##### HTTP(1.1)的性能如何？

​	HTTP是基于 TCP/IP,使用了 请求-应答 的通信模式

​	1.**长连接**：在HTTP(1.0)中，每次发起一个请求都建立一次TCP连接，且是串行请求，性能低、开销大

​		而在HTTP(1.1)中，提出了**长连接**的通信方式（只要任意一端没有明确提出断开连接，则保持 TCP 连接状态），减少了重复建立和断开连接的开销

​	2.**管道网络传输**

##### HTTP和HTTPS区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

3. HTTP 的端口号是 80，HTTPS 的端口号是 443。

4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

##### HTTPS如何解决HTTP中的不安全问题



##### HTTPS是如何建立连接的？

​	SSL/TLS 协议基本流程：* 客户端向服务器索要并验证服务器的公钥。

​											  * 双方协商生产「会话秘钥」。

​											  * 双方采用「会话秘钥」进行加密通信。

##### HTTP/1.0    HTTP/1.1     HTTP/2     HTTP/3 优化



# MySQL

# Linux

# 

# JVM

### 1、从栈帧看字节码如何在JVM中流转

怎么查看字节码文件？

对象初始化后，具体字节码怎么执行？

#### 分析字节码的小工具：

①  javap    将 .class 字节码文件解析成可读的文件格式

javap -v 

javap -p 打印私有字段和方法

```java
javap -p -v HelloWorld
```

在 **Stack Overflow** 上有一个非常有意思的问题：我在某个类中增加一行注释之后，为什么两次生成的 **.class** 文件，它们的 **MD5** 是不一样的？

这是因为在 **javac** 中可以指定一些额外的内容输出到字节码。经常用的有

* javac -g:lines 强制生成 LineNumberTable。
* javac -g:vars  强制生成 LocalVariableTable。
* javac -g 生成所有的 debug 信息

②  **jclasslib** 图形化工具，直观的查询字节码中的内容

​         Idea 中有插件，可以从 plugins 中搜索到



##### 类的初始化发生在类的加载阶段

##### 对象的创建方式有什么？

* new

* Class 的 newInstance 方法

* Constructor 类的 newInstance 方法

* 反序列化                                      （未调用构造方法）

* Object 的 clone 方法                  （未调用构造方法）

  

![image-20200815005040962](C:\Users\氮蛋\AppData\Roaming\Typora\typora-user-images\image-20200815005040962.png)

A 和 B 会被加载到元空间的方法区，进入 main 方法后，将会交给执行引擎执行。

这个执行过程是在栈上完成的，其中有几个重要的区域，包括虚拟机栈、程序计数器等



#### 查看字节码

##### 命令行查看

↓ 编译源代码 A.java

```java
javac -g:lines -g:vars A.java
```

这将强制生成 LineNumberTable 和 LocalVariableTable

后使用 javap 命令查看 A 和 B 的字节码

```java
javap -p -v A.class
javap -p -v B.class
```

这个命令不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息

```java
javap 中显示的字样
1: invokespecial #1                  // Method java/lang/Object."<init>":()V
```

对象的初始化，首先调用了 Object 类的初始化方法，注意 <init> 

##### clinit  和 init

<clinit>方法在类加载过程中执行的，而<init>在对象实例化时执行,所以<clinit>一定比<init>先执行

<init>:会将变量初始化,初始化语句块，构造器方法等操作顺序封装到该方法中

- 父类的静态变量初始化
- 父类的静态代码块
- 子类的静态变量初始化
- 子类的静态代码块
- 父类的变量初始化
- 父类的初始化代码块
- 父类的构造方法
- 子类的变量初始化
- 子类的初始化代码块
- 子类的构造方法